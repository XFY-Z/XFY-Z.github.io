<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>瑞吉外卖项目总结</title>
      <link href="/2022/12/16/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2022/12/16/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>博主最近在学习开发后端项目，因为没有做项目的基础，所以找了黑马的瑞吉外卖项目练练手。开始做这个项目的时候还是在学校，最近也是回到了家里。这几天就把在学校里差的内容做完了，从开始做这个项目到结束差不多一个月的时间。而瑞吉外卖这个项目更多的CRUD，调用API和库，总体上功能简单，没有什么难点，也没有高并发的场景可供调优实践。但是在其中还是学习到很多知识，所以写下这篇博客来总结项目。</p><h2 id="后端Controller层返回结果统一封装为R对象"><a href="#后端Controller层返回结果统一封装为R对象" class="headerlink" title="后端Controller层返回结果统一封装为R对象"></a>后端Controller层返回结果统一封装为R对象</h2><p>后端的Controller层接收完前端的请求后，要返回什么样的结果是需要按情况变化的，但是如果每一个Controller返回的结果是不一样的，前端也要用不同的数据类型来接收。为了避免麻烦，前后端指定统一的controller层返回对象类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">R</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code; <span class="comment">//编码：1成功，0和其它数字为失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//错误信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data; <span class="comment">//数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">//动态数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="title function_">success</span><span class="params">(T object)</span> &#123;</span><br><span class="line">        R&lt;T&gt; r = <span class="keyword">new</span> <span class="title class_">R</span>&lt;T&gt;();</span><br><span class="line">        r.data = object;</span><br><span class="line">        r.code = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; R&lt;T&gt; <span class="title function_">error</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">R</span>();</span><br><span class="line">        r.msg = msg;</span><br><span class="line">        r.code = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> R&lt;T&gt; <span class="title function_">add</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到我们可以使用这个类中静态方法，并且静态方法是使用了泛型来定义data数据类型的。我们可以举个<strong>手机端退出功能</strong>的例子来演示下前端发送请求到后端，后端响应成功并把数据封装到R对象中。可以看到在写Controller方法时确定返回数据类型为R类型对象其中数据类型为String。这样后端返回给前端的信息为code&#x3D;1 data&#x3D;”退出成功”，之后再由前端对返回的数据进行判断做出下一步操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 退出功能</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@PostMapping(&quot;/loginout&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">loginout</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">       <span class="comment">//清理保存在session对象中的属性(user)的值</span></span><br><span class="line">       session.removeAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> R.success(<span class="string">&quot;退出成功&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="定义静态资源映射关系"><a href="#定义静态资源映射关系" class="headerlink" title="定义静态资源映射关系"></a>定义静态资源映射关系</h2><p>静态资源映射关系主要用于将前端请求的URL路径与后端服务器资源路径进行映射。在Springboot中静态 资源是默认放在static目录下，如果你要把静态资源放在其他目录下，就必须配置静态资源映射关系。否则前端的请求将匹配不到资源。</p><p>设置静态资源映射关系后端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="comment">//设置静态资源映射(就是启动服务后通过url访问静态资源)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/resources/&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/static/&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/public/&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="配置消息资源转换器"><a href="#配置消息资源转换器" class="headerlink" title="配置消息资源转换器"></a>配置消息资源转换器</h2><h3 id="瑞吉外卖项目中遇到的问题"><a href="#瑞吉外卖项目中遇到的问题" class="headerlink" title="瑞吉外卖项目中遇到的问题"></a>瑞吉外卖项目中遇到的问题</h3><p>数据库中表的主键大都是由mybatis-plus的主键自动生成策略的雪花算法生成的，雪花算法生成的是一个Long类型的数字，而雪花算法生成的主键传输到前端的时候会出现精度缺失现象导致前端拿到的id和数据库中的id不一致。那么前端再发出请求无论是通过id查找数据还是修改数据都会因为id不一致而修改失败。</p><h3 id="精读缺失的原因"><a href="#精读缺失的原因" class="headerlink" title="精读缺失的原因"></a>精读缺失的原因</h3><p>后端使用64位存储长整数 (Long) ，而前端的JavaScript是使用53位来存储此类型数据。因此超过最大值的数，可能会出现问题。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>Springboot项目前后端资源可以采用json格式字符串，我们可以添加消息资源转换器MessageConverters，将Long类型的数据序列化为字符串，添加后Spring web mvc在处理controller返回值的时候会采用自定义的序列化策略自动将Long类型数据序列化为字符串，这样就可以解决Long类型数据精度缺失问题。</p><p>导入fastjson的maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.13.graal<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写对象映射器：JacksonObjectMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象</span></span><br><span class="line"><span class="comment"> * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]</span></span><br><span class="line"><span class="comment"> * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonObjectMapper</span> <span class="keyword">extends</span> <span class="title class_">ObjectMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DATE_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DATE_TIME_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_TIME_FORMAT</span> <span class="operator">=</span> <span class="string">&quot;HH:mm:ss&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JacksonObjectMapper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="comment">//收到未知属性时不报异常</span></span><br><span class="line">        <span class="built_in">this</span>.configure(FAIL_ON_UNKNOWN_PROPERTIES, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//反序列化时，属性不存在的兼容处理</span></span><br><span class="line">        <span class="built_in">this</span>.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class="line">        <span class="type">SimpleModule</span> <span class="variable">simpleModule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleModule</span>()</span><br><span class="line">                .addDeserializer(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br><span class="line">                .addDeserializer(LocalDate.class, <span class="keyword">new</span> <span class="title class_">LocalDateDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">                .addDeserializer(LocalTime.class, <span class="keyword">new</span> <span class="title class_">LocalTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))</span><br><span class="line"></span><br><span class="line">                .addSerializer(BigInteger.class, ToStringSerializer.instance)</span><br><span class="line">                .addSerializer(Long.class, ToStringSerializer.instance)</span><br><span class="line">                .addSerializer(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))</span><br><span class="line">                .addSerializer(LocalDate.class, <span class="keyword">new</span> <span class="title class_">LocalDateSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))</span><br><span class="line">                .addSerializer(LocalTime.class, <span class="keyword">new</span> <span class="title class_">LocalTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));</span><br><span class="line">        <span class="comment">//注册功能模块 例如，可以添加自定义序列化器和反序列化器</span></span><br><span class="line">        <span class="built_in">this</span>.registerModule(simpleModule);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写完对象映射器后，在配置扩展消息资源转换器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebMvcConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 拓展消息资源转换器</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">        MappingJackson2HttpMessageConverter messageConverter=<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">        messageConverter.setObjectMapper(<span class="keyword">new</span> <span class="title class_">JacksonObjectMapper</span>());</span><br><span class="line">        <span class="comment">//将我们自定义的消息转换器，添加进行集合中，并把优先级设置为最高</span></span><br><span class="line">        converters.add(<span class="number">0</span>,messageConverter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="什么是文件上传"><a href="#什么是文件上传" class="headerlink" title="什么是文件上传"></a>什么是文件上传</h3><p>文件上传也称为upload，是指将本地图片、视频、音频文件<strong>上传到服务器上</strong>，可以供其他用户浏览或下载的过程。文件上传在项目中应用非常广泛，我们经常发微博，发微信都用到了文件上传功能。</p><p>文件上传时，对页面的form表单有如下要求：</p><ul><li>method&#x3D;”post”，采用post方式提交数据</li><li>enctype&#x3D;”multipart&#x2F;form-data”，采用multipart格式上传文件</li><li>type&#x3D;”file”，使用input的file控件上传</li></ul><h3 id="瑞吉外卖项目中的文件上传"><a href="#瑞吉外卖项目中的文件上传" class="headerlink" title="瑞吉外卖项目中的文件上传"></a>瑞吉外卖项目中的文件上传</h3><p>瑞吉外卖项目中使用Spring框架在Spring-web包下对文件上传进行封装，大大简化了服务端代码，我们只需要在Controller的方法中声明一个MultipartFile类型的参数<strong>即可接收上传的文件</strong>。注意这里的basePath的值，他的定义的值为applicaton.yml配置文件中配置的值，这样做的好处是如果后期我们将项目部署到服务器上，我们只需要修改配置文件就可以达到修改文件上传位置的更改，方便维护。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/common&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;reggie.path&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String basePath;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="comment">//MultipartFile类型的参数即可接收上传的文件</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">upload</span><span class="params">(MultipartFile file)</span>&#123;</span><br><span class="line">        <span class="comment">//file是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件会删除</span></span><br><span class="line">        <span class="comment">//System.out.println(file);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//原始文件名,获取原始文件的后缀名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">        <span class="comment">//substring获取指定位置字符</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用UUID重新生成新的文件名，防止文件名称重复造成文件覆盖</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString()+suffix;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个目录对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(basePath);</span><br><span class="line">        <span class="comment">//判断当前目录是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (!dir.exists())&#123;</span><br><span class="line">            <span class="comment">//目录不存在，需要创建</span></span><br><span class="line">            dir.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将临时文件(.temp)转存到指定位置(/x.jpg)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(basePath+fileName));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回显给前端页面图片文件的名称，供给文件下载方法使用</span></span><br><span class="line">        <span class="keyword">return</span> R.success(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><h3 id="什么是文件下载"><a href="#什么是文件下载" class="headerlink" title="什么是文件下载"></a>什么是文件下载</h3><p>文件下载也称为download，是指将文件从服务器传输到本地计算机的过程。通过浏览器进行文件下载，通常有两种表现形式：1.以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录。2.直接在浏览器页面展示</p><p>其实浏览器上进行文件下载，<strong>本质上就是服务端将文件以流的方式写回浏览器的过程</strong></p><h3 id="瑞吉项目中的文件下载"><a href="#瑞吉项目中的文件下载" class="headerlink" title="瑞吉项目中的文件下载"></a>瑞吉项目中的文件下载</h3><p>查看菜品管理页面中文件上传的组件，img标签展示图片，src代表图片存在的位置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-upload</span> <span class="attr">class</span>=<span class="string">&quot;avatar-uploader&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">action</span>=<span class="string">&quot;/common/upload&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">:show-file-list</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">:on-success</span>=<span class="string">&quot;handleAvatarSuccess&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">:before-upload</span>=<span class="string">&quot;beforeUpload&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">ref</span>=<span class="string">&quot;upload&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-if</span>=<span class="string">&quot;imageUrl&quot;</span> <span class="attr">:src</span>=<span class="string">&quot;imageUrl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;avatar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">v-else</span> <span class="attr">class</span>=<span class="string">&quot;el-icon-plus avatar-uploader-icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-upload</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到如果菜品管理页面中的文件上传成功，则**保存文件到服务器中然后返回给前端页面文件名称 (请看文件上传代码最后回显给前端文件名称)**。文件上传成功后触发回调函数on-success&#x3D;”handleAvatarSuccess”，发送Get请求，其中请求参数name的值为文件上传回显中的数据，也就是文件名称。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleAvatarSuccess (response, file, fileList) &#123;</span><br><span class="line">              <span class="variable language_">this</span>.<span class="property">imageUrl</span> = <span class="string">`/common/download?name=<span class="subst">$&#123;response.data &#125;</span>`</span></span><br><span class="line">          &#125;,</span><br></pre></td></tr></table></figure><p>我们在后端处理文件下载请求代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 文件下载</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/download&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">download</span><span class="params">( String name, HttpServletResponse response)</span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//输入流，通过输入流读取文件内容(字节)</span></span><br><span class="line">           <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(basePath + name));</span><br><span class="line"></span><br><span class="line">           <span class="comment">//输出流，通过输出流将文件写回浏览器，在浏览器回显展示图片</span></span><br><span class="line">           <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//确定回显的类型</span></span><br><span class="line">           response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//通过边读边写的方式写回到浏览器中</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">           <span class="type">byte</span>[] bytes=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">           <span class="keyword">while</span> ((len = fileInputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                   outputStream.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                   outputStream.flush();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//关闭资源</span></span><br><span class="line">           outputStream.close();</span><br><span class="line">           fileInputStream.close();</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>文件下载，通过文件上传返回给页面的文件名称+basePath找到服务器中存储的文件，然后通过IO流边读边写到浏览器中，这时候imageUrl 在浏览器中展示的就是一副对应的图片，这时候前端再通过img标签进行展示就可以展示我们上传或者服务器中的图片。</p><h2 id="Mybatis-Plus的使用"><a href="#Mybatis-Plus的使用" class="headerlink" title="Mybatis-Plus的使用"></a>Mybatis-Plus的使用</h2><h3 id="项目中使用Mybatis-Plus"><a href="#项目中使用Mybatis-Plus" class="headerlink" title="项目中使用Mybatis-Plus"></a>项目中使用Mybatis-Plus</h3><p>在瑞吉外卖项目中通过使用Mybatis-Plus框架确实明显提高了开发效率，不需要像以往在mapper映射文件中写单独的配置文件mapper.xml。可以简化LambdaQueryWrapper类和LambdaUpdateWrapper类构造查询条件或者修改条件就可以代替在xml配置文件中写sql语句，大大简化开发。同时mapper接口和Service接口和实现类都只需要实现或继承框架指定的类就可以。</p><p>使用mybatis-plus我们需要在springboot项目中的application.yml进行相关配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">ASSIGN_ID</span> <span class="comment">#mybatis-plus中提供的雪花算法</span></span><br></pre></td></tr></table></figure><p>mapper接口：</p><p>只需要继承mybatis-plus中提供BaseMapper<T>接口就可以实现基础的CRUD操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DishMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Dish&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DishService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Dish&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>serviceImpl类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DishServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;DishMapper, Dish&gt; <span class="keyword">implements</span> <span class="title class_">DishService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mybatis-plus分页查询组件的使用"><a href="#Mybatis-plus分页查询组件的使用" class="headerlink" title="Mybatis-plus分页查询组件的使用"></a>Mybatis-plus分页查询组件的使用</h3><p>Mybatis-plus为我们提供了一个十分好用的分页查询功能，它是基于AOP的思想实现的。要使用这个功能的话，我们只需要写一个配置类，为mybatis-plus提供分页插件拦截器PaginationInnerInterceptor类，对mybatis-plus框架功能进行增强。</p><ol><li><p>分页插件的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* mybatis-plus分页插件的配置</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">getMybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        MybatisPlusInterceptor mybatisPlusInterceptor=<span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> mybatisPlusInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>分页插件的使用<br>我们只需要返回给页面page类型的数据，那么执行的SQL语句就会加上Limit来实现查询固定数量数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 分类数据的分页查询</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/backend/page/category/queryCategoryForPage.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;Page&lt;Category&gt;&gt; <span class="title function_">queryCategoryForPage</span><span class="params">(Integer page,Integer pageSize)</span>&#123;</span><br><span class="line">    <span class="comment">//准备分页条件构造器</span></span><br><span class="line">    Page&lt;Category&gt; pageInfo=<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(page,pageSize);</span><br><span class="line">    <span class="comment">//进行排序条件的构造</span></span><br><span class="line">    <span class="comment">//排序条件: 先按type排序，type相同按sort排序</span></span><br><span class="line">    LambdaQueryWrapper&lt;Category&gt; queryWrapper=<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.orderByAsc(Category::getType,Category::getSort);</span><br><span class="line">    <span class="comment">//在进行完分页查询后，会把查询结果回调设置会pageInfo里面</span></span><br><span class="line">    categoryService.page(pageInfo,queryWrapper);</span><br><span class="line">    <span class="keyword">return</span> R.success(pageInfo);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><h3 id="Mybatis-plus-提供的公共字段自动填充功能的使用"><a href="#Mybatis-plus-提供的公共字段自动填充功能的使用" class="headerlink" title="Mybatis-plus 提供的公共字段自动填充功能的使用"></a>Mybatis-plus 提供的公共字段自动填充功能的使用</h3><p>公共字段的含义：<br>在数据库表与表中共同含有的字段，在瑞吉外卖项目中如：createUser、createTime、updateUser、updateTime这些字段都是通用的每一张表中都有这些字段。此时如果每个表的每次操作都考虑这些填充字段是十分繁琐的，代码重复率高。mybatis-plus可以通过简单配置MetaObjectHandler (元数据处理器) 就能够在每一个sql语句到达数据库之前检查对象是否有这些字段并进行自动注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 自定义元数据对象处理器</span></span><br><span class="line"><span class="comment">* 完成公共字段自动填充功能</span></span><br><span class="line"><span class="comment">* 难点:如何动态的获得当前用户的id</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(metaObject.hasSetter(<span class="string">&quot;createUser&quot;</span>))&#123;</span><br><span class="line">            metaObject.setValue(<span class="string">&quot;createUser&quot;</span>, UserIdContextHolder.getContextHolder());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(metaObject.hasSetter(<span class="string">&quot;createTime&quot;</span>))&#123;</span><br><span class="line">            metaObject.setValue(<span class="string">&quot;createTime&quot;</span>, DateUtils.formatDateTime(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(metaObject.hasSetter(<span class="string">&quot;updateUser&quot;</span>))&#123;</span><br><span class="line">            metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>, UserIdContextHolder.getContextHolder());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(metaObject.hasSetter(<span class="string">&quot;updateTime&quot;</span>))&#123;</span><br><span class="line">            metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>, DateUtils.formatDateTime(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了编写元数据处理器外，还需要在每一个实体类中的属性打上注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;employee&quot;)</span><span class="comment">//对应数据库中的表名</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String idNumber;<span class="comment">//身份证号码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span>    <span class="comment">//插入时填充字段</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span>     <span class="comment">//插入和更新时填充字段</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span>    <span class="comment">//插入时填充字段</span></span><br><span class="line">    <span class="keyword">private</span> Long createUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span>     <span class="comment">//插入和更新时填充字段</span></span><br><span class="line">    <span class="keyword">private</span> Long updateUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局异常处理器的使用与配置"><a href="#全局异常处理器的使用与配置" class="headerlink" title="全局异常处理器的使用与配置"></a>全局异常处理器的使用与配置</h2><p>当请求发送到controller之后，调用service进行业务操作。一旦报错，我们一般会在controller中使用try-catch进行异常捕获。但是这个方法有一定的弊端，try-catch全部写到一个类中，代码更简洁，复用性更高。</p><p>定义全局异常类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局异常处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice(annotations = &#123;RestController.class, Controller.class&#125;)</span>   <span class="comment">//对Controller进行拦截</span></span><br><span class="line"><span class="meta">@ResponseBody</span>   <span class="comment">//响应数据封装为json数据</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobaExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常处理方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(SQLIntegrityConstraintViolationException.class)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">exceptionHandler</span><span class="params">(SQLIntegrityConstraintViolationException ex)</span>&#123;</span><br><span class="line">        log.error(ex.getMessage());</span><br><span class="line">        <span class="keyword">if</span> (ex.getMessage().contains(<span class="string">&quot;Duplicate entry&quot;</span>))&#123;</span><br><span class="line">            String[] split = ex.getMessage().split(<span class="string">&quot; &quot;</span>);<span class="comment">//split()主要是用于对一个字符串进行分割成多个字符串数组，这里是使用空格来分割</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> split[<span class="number">2</span>]+<span class="string">&quot;已经存在&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> R.error(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R.error(<span class="string">&quot;未知错误，请重试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自己的异常处理类方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(CustomException.class)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;String&gt; <span class="title function_">exceptionHandler</span><span class="params">(CustomException ex)</span>&#123;</span><br><span class="line">      <span class="comment">//在日志中打印报错的日志信息</span></span><br><span class="line">        log.error(ex.getMessage());</span><br><span class="line">      <span class="comment">//回显给页面异常信息</span></span><br><span class="line">        <span class="keyword">return</span> R.error(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以在全局异常处理器中定义自己的异常处理方法如上，我们自己定义的CustomException类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义业务异常类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);<span class="comment">//对RuntimeException的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在业务层写方法的时候，就可以去抛出我们自定义业务异常类，来被全局异常类获取。举个瑞吉外卖项目中的例子，我们项目后台系统中的分类管理页面中的删除方法。因为分类管理页面展示的是分类信息。这些信息都联系了其他信息。所以如果关联了信息就不能删除，而且要给页面回显信息。因为我们定义了全局异常处理器，所以这里我们抛出了异常，全局异常处理类就会处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据id删除,category表中的id对应着Dish表中的category_id，Setmeal表中的Category_id</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">      <span class="comment">//查询当前分类是否关联了菜品，如果已经关联，抛出一个业务异常</span></span><br><span class="line">      List&lt;DishDto&gt; dishes = dishService.getByCategoryId(id);</span><br><span class="line">      <span class="keyword">if</span> (dishes!=<span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="comment">//如果关联了菜品，抛出一个业务异常</span></span><br><span class="line">         <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;当前分类下关联了菜品，不能删除&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//查询当前分类是否关联了套餐，如果已经关联，抛出一个业务异常</span></span><br><span class="line">      List&lt;Setmeal&gt; setmeals = setmealService.getByCategoryId(id);</span><br><span class="line">      <span class="keyword">if</span> (setmeals!=<span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="comment">//如果关联了套餐，抛出一个业务异常</span></span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;当前分类下关联了套餐，不能删除&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//正常删除</span></span><br><span class="line">      categoryDao.deleteById(id);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="DTO数据传输对象的使用"><a href="#DTO数据传输对象的使用" class="headerlink" title="DTO数据传输对象的使用"></a>DTO数据传输对象的使用</h2><p>在WEB项目中经常会遇到一种情况，前端传输的参数在后端controller层中原有的对象无法全部接收到前端传输的所有参数，因此我们可以创建一个原有对象对应的DTO对象继承原有对象，拓展新的属性以便接收前端传输的全部参数。</p><p>这一点在后端controller层返回值中也可以体现，瑞吉外卖项目中，controller的返回值封装成R对象中的data属性，即我们需要用一个对象封装前端想要的所有参数而返回，但有时候前端想要的所有数据可能后端已有的类都无法一个对象封装所有参数。因此我们可以在原有的类基础上继承一个子类拓展属性来满足要求。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DishDTO</span> <span class="keyword">extends</span> <span class="title class_">Dish</span> &#123;</span><br><span class="line">    <span class="comment">//封装了口味集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;DishFlavor&gt; flavors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜品分类名称 后端数据库有的是categoryId但前端需要菜品分类的名称，原有的Dish对象不再能满足需求。在DishDTO中拓展categoryName属性满足条件.</span></span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜品的份数  前端传输菜品数据的时候会一并传输用户点这菜的份数，而后端的Dish对象无法封装菜品数目，于是在DishDTO中拓展copies属性以满足需要。</span></span><br><span class="line">    <span class="keyword">private</span> Integer copies;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DishDTO&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;flavors=&quot;</span> + flavors +</span><br><span class="line">                <span class="string">&quot;, categoryName=&#x27;&quot;</span> + categoryName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, copies=&quot;</span> + copies +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>瑞吉外卖项目中，我们使用redis来分担数据库的压力。而redis是二进制安全的，在redis中存储的数据其实是经过序列化的字节流，而redis中数据类型仅仅代表数据的组织结构，并不是值其真实存储的数据。在实际项目中我们需要将redis作为缓存使用，将从数据库中查询出来的数据存储在redis中，而查询出来的数据一般都是对象，List集合，甚至需要将map存进redis当中，这时后我们就需要考虑要使用redis提供的啥数据类型进行存储。</p><h3 id="Redis-Template"><a href="#Redis-Template" class="headerlink" title="Redis Template"></a>Redis Template</h3><p>在项目中，我们可以统一用redis中的字符串类型来存储，将对象序列化为字节数组然后以字符串的形式保存在数据库当中。这样我们只需要配置RedisTemplate的value序列方式为JdkSerializationRedisSerializer,就可以将jave中的对象序列化为字符串，然后读出来的时候以同样的方式反序列化。而Redis支持很多语言，我们以JDK序列化器序列化的对象，别的语言写的服务器就无法正确的反序列化可能会导致乱码问题。如果真有这种需求可以考虑统一序列化为json格式的字符串，那么所有类型都能够访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//默认的Key序列化器为：JdkSerializationRedisSerializer</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Spring-Chche简化开发"><a href="#使用Spring-Chche简化开发" class="headerlink" title="使用Spring Chche简化开发"></a>使用Spring Chche简化开发</h3><p>缓存一般都是用来解决读请求的，来降低落到mysql的访问压力，而当数据发生写操作时，根据实际需求可能需要删除redis缓存或者同步缓存和数据库的数据。对于一些简单的逻辑我们完全可以用注解来实现，比如需要使用缓存的读请求，一般都是先看缓存中有没有，如果有直接从缓存中拿，没有去mysql中拿并回写到缓存中。spring cache框架支持用简单的注解来满足简单的使用缓存的需求，但若是有较为复杂的逻辑还需要自己来实现。</p><p>配置：</p><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span> // 导入redis的依赖关系</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-cache --&gt;</span> // 导入spring-cache的依赖包</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.233</span><span class="number">.141</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span> <span class="comment">#端口</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root@123456</span> <span class="comment">#redis数据库密码</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment">#选择redis0号数据库</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="number">3600000</span> <span class="comment"># redis中设置的key的默认过期时间，实际应用中为了避免缓存雪崩问题，设置的默认过期时间应该尽可能分散。</span></span><br></pre></td></tr></table></figure><p>在启动类上开启注解缓存方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">//开始mysql事务</span></span><br><span class="line"><span class="meta">@EnableCaching</span>  <span class="comment">//开启spring-cache注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReggieApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ReggieApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时可以在类中加上Spring Cache注解来使用：</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@EnableCaching</td><td>开启缓存注解功能</td></tr><tr><td>@Cacheable</td><td>在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值返回到缓存中</td></tr><tr><td>@CachePut</td><td>将方法的返回值放到缓存中</td></tr><tr><td>@CacheEvict</td><td>将一条或多条数据从缓存中删除</td></tr></tbody></table><h2 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h2><p>mysql的主从复制的目的和redis主从复制的目的几乎都是一样的，为了解决单点故障问题，主mysql数据库挂了，从mysql数据库可以继续干活。可以进行读写分离，在并发量大的时候并且是读多写少的环境下，我们可以进行读写分离，让从mysql数据库为只读，主mysql数据库即可读也可以写，相当于分担了主msyql读的并发压力，系统可用性更高。</p><h3 id="使用Sharing-JDBC框架实现MySQL读写分离"><a href="#使用Sharing-JDBC框架实现MySQL读写分离" class="headerlink" title="使用Sharing-JDBC框架实现MySQL读写分离"></a>使用Sharing-JDBC框架实现MySQL读写分离</h3><p>Sharing-JDBC定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。我们在项目中导入jar包，写好配置类，就可以实现MySQL读写分离。</p><p>pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--sharding-jdbc--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0-RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yml配置读写分离的相关参数，就可以实现读写分离了。注意一下配置文件中格式就好。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">shardingsphere:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">names:</span> <span class="string">master,slave</span></span><br><span class="line">    <span class="comment"># 主数据源</span></span><br><span class="line">    <span class="attr">master:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.10.101:3306/xfy?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&#x27;!Zbyzby1124123&#x27;</span></span><br><span class="line">    <span class="comment"># 从数据源</span></span><br><span class="line">    <span class="attr">slave:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.10.102:3306/xfy?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&#x27;!Zbyzby1124123&#x27;</span></span><br><span class="line">  <span class="attr">masterslave:</span></span><br><span class="line">    <span class="comment"># 读写分离配置</span></span><br><span class="line">    <span class="attr">load-balance-algorithm-type:</span> <span class="string">round_robin</span> <span class="comment">#轮询</span></span><br><span class="line">    <span class="comment"># 最终的数据源名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dataSource</span></span><br><span class="line">    <span class="comment"># 主库数据源名称</span></span><br><span class="line">    <span class="attr">master-data-source-name:</span> <span class="string">master</span></span><br><span class="line">    <span class="comment"># 从库数据源名称列表，多个逗号分隔</span></span><br><span class="line">    <span class="attr">slave-data-source-names:</span> <span class="string">slave</span></span><br><span class="line">  <span class="attr">props:</span></span><br><span class="line">    <span class="attr">sql:</span></span><br><span class="line">      <span class="attr">show:</span> <span class="literal">true</span> <span class="comment">#开启SQL显示，默认false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
